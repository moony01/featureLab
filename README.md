## 담당자 역할
### 한문희

- Spring boot 프로젝트 생성
- 프론트엔드 Nuxt.js 프로젝트 생성
- Github 저장소 생성 및 버전관리
- 시스템 설계도 작성
- Chat gpt 에서 GPTs 생성 후 프로젝트 학습
- 의존성 관리 및 설치

## 사용 스킬

- Spring boot
- Vue.js
- Nuxt.js
- Quasar
- Sass
- Git
- GPTs

## 시스템 설계도


## 프로젝트 환경세팅
작성 준비중....

## 프로젝트 구조 설명

우리 프로젝트는 크게 일반적인 Gradle을 사용한 JAVA 프로젝트 구조입니다. 해당 프로젝트에 참여한 개발자들이 자유롭게 기능을 구현하고 스터디를 통해 자신이 개발 한 내용을 공유하고 연습 할 수 있는 토이 프로젝트입니다.

- .git: 버전 관리를 위한 Git 저장소 디렉터리
- .gitignore: Git에서 추적하지 않을 파일 목록을 지정하는 파일
- .gradle: Gradle 빌드 도구와 관련된 설정 및 캐시 정보가 저장된 디렉터리
- .idea: IntelliJ IDEA 개발 환경 설정 파일이 있는 디렉터리
- build.gradle: 프로젝트의 빌드를 위한 Gradle 스크립트 파일
- build: 프로젝트 빌드 결과물이 저장되는 디렉터리

### build 디렉터리와 build.gradle 파일에대한 조금 더 자세한 설명

`build.gradle` 파일 안에는 프로젝트를 빌드하는데 필요한 스크립트, 설정, 의존성 정의 등이 포함되어 있습니다. 프로젝트를 빌드할 때 `gradlew build` 같은 명령어를 실행하면, Gradle은 build.gradle 파일의 지시에 따라 소스 코드를 컴파일하고, 필요한 라이브러리를 다운로드하며, 테스트를 실행하고, 최종적으로 빌드 결과물을 생성합니다.

이렇게 생성된 빌드 결과물은 우리 프로젝트에서는 `build` 디렉터리 내에 저장됩니다. 일반적으로도 그러합니다. Java 프로젝트의 경우, build/classes에 컴파일된 클래스 파일들이 저장되고, build/libs에는 프로젝트의 실행 가능한 JAR 파일이 생성됩니다. 또한, 테스트 결과, 문서화된 파일, 배포용 아카이브 등도 이 디렉터리에 위치합니다.

build 디렉터리의 내용을 클라우드 서비스나 네트워크 서버 등에 배포하여 실제 운영, 개발, 테스트 서버 환경에서 애플리케이션을 실행할 수 있습니다.

*   **수동 배포**: `build` 디렉터리의 내용을 직접 클라우드 서비스나 서버에 업로드합니다. 이 방법은 단순하지만, 반복적인 작업이 필요하며 실수의 여지가 있습니다.
*   **자동화 도구 사용**: Jenkins, GitLab CI/CD, GitHub Actions 등의 자동화 도구를 사용하여 빌드 및 배포 과정을 자동화합니다. 이러한 도구는 소스 코드가 저장소에 푸시될 때마다 자동으로 빌드와 테스트를 수행하고, 성공적인 빌드 결과를 서버에 자동으로 배포합니다.
*   **컨테이너화 및 오케스트레이션**: Docker와 같은 컨테이너 도구를 사용하여 애플리케이션과 그 의존성을 컨테이너 이미지로 패키징합니다. 이후 Kubernetes 같은 오케스트레이션 플랫폼을 사용하여 배포, 관리, 확장을 용이하게 합니다.

(우리의 계획은 수동 배포 테스트 이후 자동화 도구를 사용할 예정이다 컨테이너화 및 오케스트레이션은 조금 더 공부가 필요할듯 하다.)

또한 Java 웹 애플리케이션을 서버에 배포할 경우, 종종 WAR(Web Application Archive) 파일 포맷을 사용하는 것이 일반적입니다. WAR 파일은 웹 애플리케이션의 자원, Java 클래스, 라이브러리, 관련된 메타데이터를 하나의 아카이브 파일로 묶어 Tomcat, Jetty, JBoss 같은 서블릿 컨테이너에 배포할 수 있도록 합니다.

- - -

# 개발에 필요한 정보 memo....

## window 명령어
- 디렉토리 삭제
```bash
rmdir /s /q frontend
```