import{_ as O}from"./DQFWM22Q.js";import{Z as E,r as y,$ as N,a0 as R,a1 as S,W as M,g as $,a2 as C,a3 as z,a4 as H,x as d,m as T,a5 as F,q as K,a6 as w,o as V,c as j,a as m,t as b,b as G,w as U,d as W}from"./DLLq64TI.js";const Z=s=>s==="defer"||s===!1;function B(...s){var P;const n=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(n);let[e,l,a={}]=s;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof l!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=z(),h=l,_=()=>null,D=()=>t.isHydrating?t.payload.data[e]:t.static.data[e];a.server=a.server??!0,a.default=a.default??_,a.getCachedData=a.getCachedData??D,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??E.deep,a.dedupe=a.dedupe??"cancel";const c=()=>a.getCachedData(e,t)!=null;if(!t._asyncData[e]||!a.immediate){(P=t.payload._errors)[e]??(P[e]=null);const i=a.deep?y:N;t._asyncData[e]={data:i(a.getCachedData(e,t)??a.default()),pending:y(!c()),error:R(t.payload._errors,e),status:y("idle")}}const r={...t._asyncData[e]};r.refresh=r.execute=(i={})=>{if(t._asyncDataPromises[e]){if(Z(i.dedupe??a.dedupe))return t._asyncDataPromises[e];t._asyncDataPromises[e].cancelled=!0}if((i._initial||t.isHydrating&&i._initial!==!1)&&c())return Promise.resolve(a.getCachedData(e,t));r.pending.value=!0,r.status.value="pending";const f=new Promise((u,o)=>{try{u(h(t))}catch(p){o(p)}}).then(async u=>{if(f.cancelled)return t._asyncDataPromises[e];let o=u;a.transform&&(o=await a.transform(u)),a.pick&&(o=I(o,a.pick)),t.payload.data[e]=o,r.data.value=o,r.error.value=null,r.status.value="success"}).catch(u=>{if(f.cancelled)return t._asyncDataPromises[e];r.error.value=H(u),r.data.value=d(a.default()),r.status.value="error"}).finally(()=>{f.cancelled||(r.pending.value=!1,delete t._asyncDataPromises[e])});return t._asyncDataPromises[e]=f,t._asyncDataPromises[e]},r.clear=()=>q(t,e);const v=()=>r.refresh({_initial:!0}),x=a.server!==!1&&t.payload.serverRendered;{const i=T();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const o=i._nuxtOnBeforeMountCbs;S(()=>{o.forEach(p=>{p()}),o.splice(0,o.length)}),M(()=>o.splice(0,o.length))}x&&t.isHydrating&&(r.error.value||c())?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):i&&(t.payload.serverRendered&&t.isHydrating||a.lazy)&&a.immediate?i._nuxtOnBeforeMountCbs.push(v):a.immediate&&v();const f=F();if(a.watch){const o=$(a.watch,()=>r.refresh());f&&C(o)}const u=t.hook("app:data:refresh",async o=>{(!o||o.includes(e))&&await r.refresh()});f&&C(u)}const g=Promise.resolve(t._asyncDataPromises[e]).then(()=>r);return Object.assign(g,r),g}function q(s,n){n in s.payload.data&&(s.payload.data[n]=void 0),n in s.payload._errors&&(s.payload._errors[n]=null),s._asyncData[n]&&(s._asyncData[n].data.value=void 0,s._asyncData[n].error.value=null,s._asyncData[n].pending.value=!1,s._asyncData[n].status.value="idle"),n in s._asyncDataPromises&&(s._asyncDataPromises[n].cancelled=!0,s._asyncDataPromises[n]=void 0)}function I(s,n){const e={};for(const l of n)e[l]=s[l];return e}const Q=K({__name:"proxyTest",async setup(s){let n,e;const l=y(0),{data:a,refresh:t}=([n,e]=w(()=>B(()=>$fetch("http://localhost:8080/min/api/test",{params:{page:l.value++}}),"$ESEOfUmeGb")),n=await n,e(),n),{data:h,refresh:_}=([n,e]=w(()=>B(()=>$fetch("/min/api/test",{params:{page:l.value++}}),"$WBkGNKZzl8")),n=await n,e(),n);return console.log("fullPathData : ",a.value),console.log("relativePathData : ",h.value),(D,c)=>{const r=O;return V(),j("div",null,[m("button",{onClick:c[0]||(c[0]=()=>d(t)())},"refreshFullPath"),m("div",null,"fullPathData : "+b(d(a)),1),m("button",{onClick:c[1]||(c[1]=()=>d(_)())},"refreshRelativePath"),m("div",null,"relativePathData : "+b(d(h)),1),G(r,{to:"/"},{default:U(()=>[W("home")]),_:1})])}}});export{Q as default};
